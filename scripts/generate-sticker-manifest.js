#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// Generates components/stickerManifest.ts by scanning assets/packs/{pack}/{file}
// Sticker ID format: {pack}/{name-without-ext}
// This generator only emits manifest stubs and references to existing thumbnails (if present).

const ROOT = path.resolve(__dirname, '..');
const ASSETS_PACKS = path.join(ROOT, 'assets', 'packs');
const OUT_FILE = path.join(ROOT, 'components', 'stickerManifest.ts');

function isImageFile(name) {
  return /\.(png|jpg|jpeg|webp|gif)$/i.test(name);
}

function isVideoFile(name) {
  return /\.(mp4|webm)$/i.test(name);
}

function walkPacks() {
  const manifest = [];
  if (!fs.existsSync(ASSETS_PACKS)) return manifest;
  const packs = fs.readdirSync(ASSETS_PACKS, { withFileTypes: true }).filter(d => d.isDirectory()).map(d => d.name);

  packs.forEach(pack => {
    const packDir = path.join(ASSETS_PACKS, pack);
    const files = fs.readdirSync(packDir, { withFileTypes: true }).filter(f => f.isFile()).map(f => f.name);

    // Group files by base name to support images, videos and optional thumbnails with `.thumb` suffix.
    const grouped = {};
    files.forEach(file => {
      const ext = path.extname(file);
      const base = path.basename(file, ext);
      if (base.endsWith('.thumb')) {
        const realBase = base.replace(/\.thumb$/, '');
        grouped[realBase] = grouped[realBase] || {};
        grouped[realBase].thumb = file;
        return;
      }

      if (isImageFile(file)) {
        grouped[base] = grouped[base] || {};
        grouped[base].image = file;
        return;
      }

      if (isVideoFile(file)) {
        grouped[base] = grouped[base] || {};
        grouped[base].video = file;
        return;
      }
    });

    Object.entries(grouped).forEach(([name, entry]) => {
      const id = `${pack}/${name}`;
      const relImage = entry.image ? `@/assets/packs/${pack}/${entry.image}` : null;
      const relVideo = entry.video ? `@/assets/packs/${pack}/${entry.video}` : null;
      const thumbFile = entry.thumb ? entry.thumb : null;
      const thumbRelPath = thumbFile ? `@/assets/packs/${pack}/${thumbFile}` : null;

      const relPath = relImage || relVideo || null;
      manifest.push({ id, relPath, thumbRelPath, pack, name, isVideo: !!relVideo });
    });
  });

  return manifest;
}

function generate() {
  const items = walkPacks();
  const header = `// THIS FILE IS GENERATED BY scripts/generate-sticker-manifest.js\n// Do not edit by hand. Run "npm run sticker:generate" to regenerate.\nexport type MediaItem = { source: any; thumb?: any; type: 'sticker' | 'video'; pack?: string; label?: string };\n\nexport const assetManifest: Record<string, MediaItem> = {\n`;

  const body = items.map(it => {
    const parts = [];
    if (it.relPath) parts.push(`source: require('${it.relPath}')`);
    if (it.thumbRelPath) parts.push(`thumb: require('${it.thumbRelPath}')`);
    parts.push(`type: '${it.isVideo ? 'video' : 'sticker'}'`);
    parts.push(`pack: '${it.pack}'`);
    const safeLabel = String(it.name).replace(/'/g, "\\'");
    parts.push(`label: '${safeLabel}'`);
    return `  '${it.id}': { ${parts.join(', ')} },`;
  }).join('\n');

  const footer = `\n};\n\nexport default assetManifest;\n`;

  const out = header + (body ? body + '\n' : '') + footer;
  fs.writeFileSync(OUT_FILE, out, 'utf8');
  console.log(`Written ${OUT_FILE} with ${items.length} stickers.`);
}

generate();
