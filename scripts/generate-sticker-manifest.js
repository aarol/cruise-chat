#!/usr/bin/env node
const fs = require('fs');
const path = require('path');

// Generates components/stickerManifest.ts by scanning assets/packs/{pack}/{file}
// Sticker ID format: {pack}/{name-without-ext}

const ROOT = path.resolve(__dirname, '..');
const ASSETS_PACKS = path.join(ROOT, 'assets', 'packs');
const OUT_FILE = path.join(ROOT, 'components', 'stickerManifest.ts');

function isImageFile(name) {
  return /\.(png|jpg|jpeg|webp|gif)$/i.test(name);
}

function walkPacks() {
  const manifest = [];
  if (!fs.existsSync(ASSETS_PACKS)) return manifest;
  const packs = fs.readdirSync(ASSETS_PACKS, { withFileTypes: true }).filter(d => d.isDirectory()).map(d => d.name);
  packs.forEach(pack => {
    const packDir = path.join(ASSETS_PACKS, pack);
    const files = fs.readdirSync(packDir, { withFileTypes: true }).filter(f => f.isFile()).map(f => f.name);

    // Group files by base name to support optional thumbnails with `.thumb` suffix.
    const grouped = {};
    files.forEach(file => {
      if (!isImageFile(file)) return;
      const ext = path.extname(file);
      const base = path.basename(file, ext);
      // detect thumb naming: name.thumb.png -> baseWithoutThumb = name
      if (base.endsWith('.thumb')) {
        const realBase = base.replace(/\.thumb$/, '');
        grouped[realBase] = grouped[realBase] || {};
        grouped[realBase].thumb = file;
      } else {
        grouped[base] = grouped[base] || {};
        grouped[base].orig = file;
      }
    });

    Object.entries(grouped).forEach(([name, entry]) => {
      const id = `${pack}/${name}`;
      const relPath = entry.orig ? `@/assets/packs/${pack}/${entry.orig}` : null;
      const thumbRelPath = entry.thumb ? `@/assets/packs/${pack}/${entry.thumb}` : null;
      manifest.push({ id, relPath, thumbRelPath, pack, name });
    });
  });
  return manifest;
}

function generate() {
  const items = walkPacks();
  const header = `// THIS FILE IS GENERATED BY scripts/generate-sticker-manifest.js
// Do not edit by hand. Run "npm run sticker:generate" to regenerate.
export type MediaItem = { source: any; thumb?: any; type: 'sticker'; pack?: string; label?: string };

export const assetManifest: Record<string, MediaItem> = {
`;

  const body = items.map(it => {
    const parts = [];
    if (it.relPath) parts.push(`source: require('${it.relPath}')`);
    if (it.thumbRelPath) parts.push(`thumb: require('${it.thumbRelPath}')`);
    parts.push(`type: 'sticker'`);
    parts.push(`pack: '${it.pack}'`);
    parts.push(`label: '${it.name}'`);
    return `  '${it.id}': { ${parts.join(', ')} },`;
  }).join('\n');

  const footer = `\n};\n\nexport default assetManifest;\n`;

  const out = header + (body ? body + '\n' : '') + footer;
  fs.writeFileSync(OUT_FILE, out, 'utf8');
  console.log(`Written ${OUT_FILE} with ${items.length} stickers.`);
}

generate();
